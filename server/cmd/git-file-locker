#!/usr/bin/env bash

# command format:
#
# git-file-locker --lock=<lock_flag> --repo=<repo_name> 
#       --branch=<repo_branch_name> --user=<user> --file=<lockable_file> 
#       [--no-upload] [<git_upload_pack_parameters>]
#
# lock_flag
#       acquire     To acquire lock
#       release     To release lock
#       query       To query lock
#
# repo_name
#       repo name on which file is to be locked
#
# repo_branch_name
#       repo's branch on which file is to be locked
#
# user
#       user which want to acquire the lock
#       format is "user_name<user_email>"
# lockable_file
#       file location relative from repo base dir
#
# --no-upload
#       if supplied then do not call git_upload_pack, by default it calls to
#       git_upload_pack command in the end. If this option is supplied then
#       git_upload_pack_parametes will be ignored, even if passed.
#
# git_upload_pack_parameters
#       parameters to pass to git_upload_pack command in the end
#       If mulitple paramaters are supplied then they will be joined with grammer:
#
#       PARAM=git_upload_pack parameter
#       SP=<space>
#       EMPTY=<>
#       PARAM_ENTRY=<SP><PARAM>
#       PARAM_LIST=<PARAM_ENTRY><PARAM_LIST>|<EMPTY>
#

FLAG=""
USER=""
FILE=""
BRANCH=""
PARAM=""
REPO=""
LOCK_VALIDITY="10h"         # 10 hours. after specified hours, lock becomes invalid.
NO_UPLOAD=""               # yes -> do not upload, empty to upload(default).
LOCK_FILE=""

help(){
    echo "Usage: \$ git-file-locker --lock=<lock_flag> --repo=<repo_name>"
    echo -e "\t--branch=<repo_branch_name> --user=<user> --file=<lockable_file>"
    echo -e "\t[--no-upload] [<git_upload_pack_parameters>]"
    echo -e "\n"
    echo "lock_flag"
    echo -e "\tacquire     To acquire lock"
    echo -e "\trelease     To release lock"
    echo -e "\tquery       To query lock"
    echo ""
    echo "repo_name"
    echo -e "\trepo name on which file is to be locked"
    echo ""
    echo "repo_branch_name"
    echo -e "\trepo's branch on which file is to be locked"
    echo ""
    echo "user"
    echo -e "\tuser which want to acquire the lock"
    echo -e "\tformat is 'user_name<user_email>'"
    echo ""
    echo "lockable_file"
    echo -e "\tfile location relative from repo base dir"
    echo ""
    echo "--no-upload"
    echo -e "\tif supplied then do not call git_upload_pack, by default it calls to"
    echo -e "\tgit_upload_pack command in the end. If this option is supplied then"
    echo -e "\tgit_upload_pack_parametes will be ignored, even if passed."
    echo ""
    echo "git_upload_pack_parameters"
    echo -e "\tparameters to pass to git_upload_pack command in the end"
    echo -e "\tIf mulitple paramaters are supplied then they will be joined with grammer:"
    echo ""
    echo -e "\tPARAM=git_upload_pack parameter"
    echo -e "\tSP=<space>"
    echo -e "\tEMPTY=<>"
    echo -e "\tPARAM_ENTRY=<SP><PARAM>"
    echo -e "\tPARAM_LIST=<PARAM_ENTRY><PARAM_LIST>|<EMPTY>"
    echo ""
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --lock=*)
            FLAG=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --user=*)
            USER=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --file=*)
            FILE=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --branch=*)
            BRANCH=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --repo=*)
            REPO=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --no-upload)
            NO_UPLOAD="yes"
            shift
            ;;
        --help|-h)
            help
            exit 0
            ;;
        *)
            PARAM="$param $1"
            shift
    esac
done

# LOCK FILE STRUCTURE
# <BASE_DIR>/git-file-locker/cache/locks/<repo>/<branch>/files.lck
#   files.lck ::
#   each line is a seperate lock
#   line:: <lockable_file><NUL><user><NUL><time_of lock_grant><CRLF>
#

# get base dir
if [ -d "/var/tmp" ] && [ -w "/var/tmp" ]; then
    BASE_DIR="/var/tmp"
elif [ -d "/tmp" ] && [ -w "/tmp" ]; then
    BASE_DIR="/tmp"
else
    BASE_DIR=$(dirname $(mktemp))
fi

# get cache dir
CACHE_DIR="$BASE_DIR/git-file-locker/cache/locks/$REPO/$BRANCH"

# get lock file
LOCK_FILE="$CACHE_DIR/files.lck"

# LOCK ACQUIRE
#
# check if lock acquired on same branch, on that file?
#   if not, then 
#       is push operation going on?
#           if yes, then success with warning to update file
#           if no, then acquire with success
#   if yes, then
#       is time of lock aquired within max limit?
#           if no, then delete invalid lock
#               is push operation going on?
#                   if yes, then success with warning to update file
#                   if no, then acquire with success.
#           if yes, then
#               is this same user?
#                   if no, fail with error
#                   if yes, success, with error

acquire_lock(){






}

# LOCK RELEASE
#
# check if lock acquired on same branch, on that file?
#   if no, then nothing to relase, exit with success
#   if yes,
#       is time of lock acquired within max limit?
#           if no, then invalid lock, release and return success
#           if yes,
#               is lock acquired by same user?
#                   if no, then fail with error, cant release someone else's lock
#                   if yes, release and return success

release_lock(){
    echo "release"

}

# LOCK QUERY
# check if lock-file exists of same branch?
#   if no, then there is no lock, return unlocked
#   if yes,
#       is lockable file's enrty exists in that branch's lock-file?
#           if no, then return unlocked
#           if yes,
#               is time of lock acquired within max limit?
#                   if no, then return unlocked, with message 'acquired lock has already expired'
#                   if yes, then return locked, with message 'locked to <user>'
#

query_lock(){
    echo "query"

}

[ -z "$FLAG" ] && echo "ERROR: No lock flag supplied." && help && exit 2
[ -z "$USER" ] && echo "ERROR: No user supplied." && help && exit 2
[ -z "$REPO" ] && echo "ERROR: No repo supplied." && help && exit 2
[ -z "$BRANCH" ] && echo "ERROR: No branch supplied." && help && exit 2
[ -z "$FILE" ] && echo "ERROR: No file supplied." && help && exit 2

case "$FLAG" in
    acquire)
        acquire_lock
        ;;
    release)
        release_lock
        ;;
    query)
        query_lock
        ;;
    *)
        echo "ERROR: Invalid lock flag('$FLAG') supplied."
        exit 2
        ;;
esac

if ! [ "$NO_UPLOAD" == "yes" ]; then
    git-upload-pack $PARAM
fi
