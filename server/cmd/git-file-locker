#!/usr/bin/env bash

# command format:
#
# git-file-locker --lock=<lock_flag> --repo=<repo_name> 
#       --branch=<repo_branch_name> --user=<user> --file=<lockable_file> 
#       [--no-upload] [git_upload_pack_parameters]
#
# lock_flag
#       acquire     To acquire lock
#       release     To release lock
#       query       To query lock
#
# repo_name
#       repo name on which file is to be locked
#
# repo_branch_name
#       repo's branch on which file is to be locked
#
# user
#       user which want to acquire the lock
#       format is "user_name<user_email>"
# lockable_file
#       file location relative from repo base dir
#
# --no-upload
#       if supplied then do not call git_upload_pack, by default it calls to
#       git_upload_pack command in the end. If this option is supplied then
#       git_upload_pack_parametes will be ignored, even if passed.
#
# git_upload_pack_parameters
#       parameters to pass to git_upload_pack command in the end
#       If mulitple paramaters are supplied then they will be joined with grammer:
#
#       PARAM=git_upload_pack parameter
#       SP=<space>
#       EMPTY=<>
#       PARAM_ENTRY=<SP><PARAM>
#       PARAM_LIST=<PARAM_ENTRY><PARAM_LIST>|<EMPTY>
#


FLAG=""
USER=""
FILE=""
BRANCH=""
PARAM=""
REPO=""
LOCK_VALIDITY="10h"         # 10 hours. after specified hours, lock becomes invalid.
NO_UPLOAD=""               # yes -> do not upload, empty to upload(default).

while [[ $# -gt 0 ]]; do
    case "$1" in
        --lock=*)
            FLAG=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --user=*)
            USER=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --file=*)
            FILE=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --branch=*)
            BRANCH=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --repo=*)
            REPO=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --no-upload)
            NO_UPLOAD="yes"
            shift
            ;;
        *)
            PARAM="$param $1"
            shift
    esac
done

# LOCK FILE STRUCTURE
# <git_user_home>/.cache/git-file-locker/locks/<repo_location>/branch/files.lck
#   files.lck ::
#   each line is a seperate lock
#   line:: <lockable_file><NUL><user><NUL><time_of lock_grant><CRLF>
#

# LOCK ACQUIRE
#
# check if lock acquired on same branch, on that file?
#   if not, then 
#       is push operation going on?
#           if yes, then success with warning to update file
#           if no, then acquire with success
#   if yes, then
#       is time of lock aquired within max limit?
#           if no, then delete invalid lock
#               is push operation going on?
#                   if yes, then success with warning to update file
#                   if no, then acquire with success.
#           if yes, then
#               is this same user?
#                   if no, fail with error
#                   if yes, success, with error
# 
#
#
# LOCK RELEASE
#
# check if lock acquired on same branch, on that file?
#   if no, then nothing to relase, exit with success
#   if yes,
#       is time of lock acquired within max limit?
#           if no, then invalid lock, release and return success
#           if yes,
#               is lock acquired by same user?
#                   if no, then fail with error, cant release someone else's lock
#                   if yes, release and return success
#
#
# LOCK QUERY
# check if lock-file exists of same branch?
#   if no, then there is no lock, return unlocked
#   if yes,
#       is lockable file's enrty exists in that branch's lock-file?
#           if no, then return unlocked
#           if yes,
#               is time of lock acquired within max limit?
#                   if no, then return unlocked, with message 'acquired lock has already expired'
#                   if yes, then return locked, with message 'locked to <user>'
#
#               
# ACQUIRING LOCK
# file write access must be syncronised so that only one wirte access to file, while performing.
#




if ! [ "$NO_UPLOAD" == "yes" ]; then
    git-upload-pack $PARAM
fi
