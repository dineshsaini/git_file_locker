#!/usr/bin/env bash

# command format:
#
# git-file-locker --lock=<lock_flag> --repo=<repo_name> 
#       --branch=<repo_branch_name> --user=<user> --file=<lockable_file> 
#       [--no-upload] [<git_upload_pack_parameters>]
#
# lock_flag
#       acquire     To acquire lock
#       release     To release lock
#       query       To query lock
#
# repo_name
#       repo name on which file is to be locked
#
# repo_branch_name
#       repo's branch on which file is to be locked
#
# user
#       user which want to acquire the lock
#       format is "user_name<user_email>"
# lockable_file
#       file location relative from repo base dir
#
# --no-upload
#       if supplied then do not call git_upload_pack, by default it calls to
#       git_upload_pack command in the end. If this option is supplied then
#       git_upload_pack_parametes will be ignored, even if passed.
#
# git_upload_pack_parameters
#       parameters to pass to git_upload_pack command in the end
#       If mulitple paramaters are supplied then they will be joined with grammer:
#
#       PARAM=git_upload_pack parameter
#       SP=<space>
#       EMPTY=<>
#       PARAM_ENTRY=<SP><PARAM>
#       PARAM_LIST=<PARAM_ENTRY><PARAM_LIST>|<EMPTY>
#

FLAG=""
USER=""
FILE=""
BRANCH=""
PARAM=""
REPO=""
MAX_LOCK_HOURS="10"        # 10 hours. after specified hours, lock becomes invalid.
NO_UPLOAD=""               # yes -> do not upload, empty to upload(default).
LOCK_FILE=""

help(){
    echo "Usage: \$ git-file-locker --lock=<lock_flag> --repo=<repo_name>"
    echo -e "\t--branch=<repo_branch_name> --user=<user> --file=<lockable_file>"
    echo -e "\t[--no-upload] [<git_upload_pack_parameters>]"
    echo -e "\n"
    echo "lock_flag"
    echo -e "\tacquire     To acquire lock"
    echo -e "\trelease     To release lock"
    echo -e "\tquery       To query lock"
    echo ""
    echo "repo_name"
    echo -e "\trepo name on which file is to be locked"
    echo ""
    echo "repo_branch_name"
    echo -e "\trepo's branch on which file is to be locked"
    echo ""
    echo "user"
    echo -e "\tuser which want to acquire the lock"
    echo -e "\tformat is 'user_name<user_email>'"
    echo ""
    echo "lockable_file"
    echo -e "\tfile location relative from repo base dir"
    echo ""
    echo "--no-upload"
    echo -e "\tif supplied then do not call git_upload_pack, by default it calls to"
    echo -e "\tgit_upload_pack command in the end. If this option is supplied then"
    echo -e "\tgit_upload_pack_parametes will be ignored, even if passed."
    echo ""
    echo "git_upload_pack_parameters"
    echo -e "\tparameters to pass to git_upload_pack command in the end"
    echo -e "\tIf mulitple paramaters are supplied then they will be joined with grammer:"
    echo ""
    echo -e "\tPARAM=git_upload_pack parameter"
    echo -e "\tSP=<space>"
    echo -e "\tEMPTY=<>"
    echo -e "\tPARAM_ENTRY=<SP><PARAM>"
    echo -e "\tPARAM_LIST=<PARAM_ENTRY><PARAM_LIST>|<EMPTY>"
    echo ""
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --lock=*)
            FLAG=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --user=*)
            USER=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --file=*)
            FILE=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --branch=*)
            BRANCH=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --repo=*)
            REPO=$(printf '%s' "$1"| cut -d= -f2-)
            shift
            ;;
        --no-upload)
            NO_UPLOAD="yes"
            shift
            ;;
        --help|-h)
            help
            exit 0
            ;;
        *)
            PARAM="$param $1"
            shift
    esac
done

# LOCK FILE STRUCTURE
# <BASE_DIR>/git-file-locker/cache/locks/<repo>/<branch>/files.lck
#   files.lck ::
#   each line is a seperate lock
#   line:: <lockable_file>:<user>:<time_of lock_grant><CRLF>
#

# get base dir
if [ -d "/var/tmp" ] && [ -w "/var/tmp" ]; then
    BASE_DIR="/var/tmp"
elif [ -d "/tmp" ] && [ -w "/tmp" ]; then
    BASE_DIR="/tmp"
else
    BASE_DIR=$(dirname $(mktemp))
fi

# get cache dir
CACHE_DIR="$BASE_DIR/git-file-locker/cache/locks/$REPO/$BRANCH"

# get lock file
LOCK_FILE="$CACHE_DIR/files.lck"

acquire_lock(){
    local f_lock="$LOCK_FILE.pid"
    local count=$1
    local RETVAL=0

    mkdir -p $(dirname $f_lock)
    touch $LOCK_FILE

    # try to lock lock_file for writing
    if ! [ -e $f_lock ]; then
        (set -o noclobber; printf '%s' "$$" > "$f_lock") 2> /dev/null;
    fi

    # verify if we have lock, or race condition happened
    if [ "$$" != "$(cat $f_lock)" ]; then
        # someone else acquired lock, lets try 3 more times after 0.3sec sleep
        [ -z "$count" ] && count=1
        [[ $count -ge 4 ]] && echo "Could not acquired lock, please try again." && exit 1
        sleep "0.3s"

        acquire_lock $((++count))
    fi

    # we got lock, set trap for fails
    trap "rm -f $f_lock" 0 1 2 3 9 15

    local lck_acquired=""

    local f_entry=$(sed -n "/^$FILE:/p" $LOCK_FILE)
    
    if [ -z "$f_entry" ]; then
        printf '%s:%s:%s\n' "$FILE" "$USER" "$(date '+%s')" >> $LOCK_FILE
        echo "INFO: Successfully acquired lock on File($FILE), lock is now valid for $MAX_LOCK_HOURS hour(s)."
        lck_acquired="yes"
    else
        local lck_time=$(printf '%s' "$f_entry" | cut -d: -f3)
        local valid_time=$(( lck_time + ( MAX_LOCK_HOURS * 60 * 60 ) ))
        local cur_time=$(date '+%s')

        if [[ $cur_time -lt $valid_time ]]; then
            local lck_user=$(printf '%s' "$f_entry" | cut -d: -f2)
            
            if [ "$USER" != "$lck_user" ]; then
                echo "ERROR: Can't lock File($FILE). It is already locked to '$USER'."
                RETVAL=1
            else
                local d_time=$(( valid_time - cur_time ))
                local min=$(( d_time / 60 ))
                local hrs=$(( min / 60 ))
                local t=""
                if [[ $hrs -eq 0 ]]; then
                    t="$min minute(s)"
                else
                    t="$hrs hour(s)"
                fi
                echo "INFO: You already have the lock, valid for $t."
            fi
        else
            # remove invalid lock
            sed -i "/^$FILE:/d" $LOCK_FILE

            printf '%s:%s:%s\n' "$FILE" "$USER" "$(date '+%s')" >> $LOCK_FILE
            echo "INFO: Successfully acquired lock on File($FILE), lock is now valid for $MAX_LOCK_HOURS hour(s)."
            lck_acquired="yes"
        fi
    fi

    if [ "$lck_acquired" == "yes" ] && [ -f "$CACHE_DIR/push.lck" ]; then
        echo "WARN: Someone is pushing changes, please update file before edit."
    fi

    # release lock, and remove trap
    rm -f $f_lock
    trap - 0 1 2 3 9 15
    [[ $RETVAL -gt 0 ]] && exit $RETVAL
}

# LOCK RELEASE
#
# check if lock acquired on same branch, on that file?
#   if no, then nothing to relase, exit with success
#   if yes,
#       is time of lock acquired within max limit?
#           if no, then invalid lock, release and return success
#           if yes,
#               is lock acquired by same user?
#                   if no, then fail with error, cant release someone else's lock
#                   if yes, release and return success

release_lock(){
  echo "release"

}

# LOCK QUERY
# check if lock-file exists of same branch?
#   if no, then there is no lock, return unlocked
#   if yes,
#       is lockable file's enrty exists in that branch's lock-file?
#           if no, then return unlocked
#           if yes,
#               is time of lock acquired within max limit?
#                   if no, then return unlocked, with message 'acquired lock has already expired'
#                   if yes, then return locked, with message 'locked to <user>'
#

query_lock(){
    echo "query"

}

[ -z "$FLAG" ] && echo "ERROR: No lock flag supplied." && help && exit 2
[ -z "$USER" ] && echo "ERROR: No user supplied." && help && exit 2
[ -z "$REPO" ] && echo "ERROR: No repo supplied." && help && exit 2
[ -z "$BRANCH" ] && echo "ERROR: No branch supplied." && help && exit 2
[ -z "$FILE" ] && echo "ERROR: No file supplied." && help && exit 2

case "$FLAG" in
    acquire)
        acquire_lock
        ;;
    release)
        release_lock
        ;;
    query)
        query_lock
        ;;
    *)
        echo "ERROR: Invalid lock flag('$FLAG') supplied."
        exit 2
        ;;
esac

if ! [ "$NO_UPLOAD" == "yes" ]; then
    git-upload-pack $PARAM
fi
